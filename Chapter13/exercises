#problem 1
#"I think we can just use negative indecies, at least on a cenceptual level. Let's write these out"

from typing import Any
#while loop version
def linearWhileNeg(lst: list, value: Any) -> int:
  i = -1
  listLength = len(lst) * -1
  while i != listLength and lst[i] != value:
    i = i - 1
  if i == listLength:
    return 0
  else:
    return i

#for loop version
#spoilers, this first draft is wrong
def linearForNeg(lst: list, value: Any) -> int:
  i = -1
  for i in range(-1, (len(lst) * -1)):
    if lst[i] == value:
      return i
  return 0

#sentinel search version
#this first draft doesn't work either'
def SentinelNeg(lst: list, value: Any) -> int:
  #insert the value at the, ahem, "end"
  lst.insert((len(lst)*-1), value)
  i = -1
  while lst[i] != value:
    i = i - 1
  lst.remove((len(lst)*-1))
  if i == len(lst)*-1:
    return 0
  else:
    return i

#tests
>>> testList = [1, 2, 3, 4, 5]
>>> linearWhileNeg(testList, 3)
-3
#so far so good
>>> linearForNeg(testList, 3)
0
#looks like the range() function doesn't want to do that'

>>> SentinelNeg(testList, 3)
Traceback (most recent call last):
  File "<pyshell#14>", line 1, in <module>
    SentinelNeg(testList, 3)
  File "<pyshell#13>", line 7, in SentinelNeg
    lst.remove((len(lst)*-1))
ValueError: list.remove(x): x not in list
#ouch, back to the drawing board

#problem 1 second drafts
def linearSentinelNeg(lst: list, value: Any) -> int:
    lst.insert((len(lst)*-1), value)
    i = -1
    while lst[i] != value:
      i = i - 1
    del lst[len(lst)*-1]
    if i == len(lst)*-1:
      return 0
    else:
      return i
>>> testList = [1, 2, 3, 4, 5]
>>> linearSentinelNeg(testList, 3)
-3

def linearForNeg(lst: list, value: Any) -> int:
  i = -1
  for i in range((len(lst) * -1), -1):
    if lst[i] == value:
      return i
  return 0
>>> linearForNeg(testList, 3)
-3
#yay all three work now

#problem 2
#assuming list [1, 2, 3, 4, 3, 5] and target value 3
#negative while and negative Sentinel will find the right-most 3
#negative for will find the leftmost 3

#problem 3
#the book says Binary Search has O(log2 N)
#sorting costs O(N log2 N)
#So I would assume we have to run a search algorithm at least N times before "sort + binary search" becomes more efficient than "linear search"

#problem 4
#our list is [6, 5, 4, 3, 7, 1, 2]
#should I write this out by hand or just add a print statement to the sorts?
#let's write it out by hand for now

#selection sort:
[6, 5, 4, 3, 7, 1, 2]
[1, 5, 4, 3, 7, 6, 2]
[1, 2, 4, 3, 7, 6, 5]
[1, 2, 3, 4, 7, 6, 5]
[1, 2, 3, 4, 5, 6, 7]

#insertion sort:
[6, 5, 4, 3, 7, 1, 2]
[5, 6, 4, 3, 7, 1, 2]
[4, 5, 6, 3, 7, 1, 2]
[3, 4, 5, 6, 7, 1, 2]
[1, 3, 4, 5, 6, 7, 2]
[1, 2, 3, 4, 5, 6, 7]

#problem 5
Bubble sort time
First, establish an itorator that compares list[X] with list[X + 1]
If X is larger, swap their positions. Then increment the itorator
Iterate over the list over and over until it is sorted

def bubbleSortTime(someList: list) -> list:
  isSorted = False
  listLength = len(someList) - 1
  while isSorted == False:
    x = 0
    y = 1
    sortItor = 0
    while y < listLength:
      if someList[x] > someList[y]:
        temp = someList[x]
        someList[x] = someList[y]
        someList[y] = temp
      x += 1
      y += 1
    #also we have to check if the darn thing is sorted
    isSorted = True
    while sortItor < listLength:
      if someList[sortItor] > someList[sortItor + 1]:
        isSorted = False
  return someList

#need to debug this
#testerList = [3, 4, 7, 1, 2, 5]
